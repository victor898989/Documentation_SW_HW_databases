https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#parentbased
https://www.w3.org/TR/trace-context-2/

Tracing SDK
Status: Stable, except where otherwise specified

Table of Contents
Tracer Provider
Tracer Creation
It SHOULD only be possible to create Tracer instances through a TracerProvider (see API).

The TracerProvider MUST implement the Get a Tracer API.

The input provided by the user MUST be used to create an InstrumentationScope instance which is stored on the created Tracer.

Status: Development - The TracerProvider MUST compute the relevant TracerConfig using the configured TracerConfigurator, and create a Tracer whose behavior conforms to that TracerConfig.

Configuration
Configuration ( i.e., SpanProcessors, IdGenerator, SpanLimits, Sampler, and (Development) TracerConfigurator) MUST be owned by the TracerProvider. The configuration MAY be applied at the time of TracerProvider creation if appropriate.

The TracerProvider MAY provide methods to update the configuration. If configuration is updated (e.g., adding a SpanProcessor), the updated configuration MUST also apply to all already returned Tracers (i.e. it MUST NOT matter whether a Tracer was obtained from the TracerProvider before or after the configuration change). Note: Implementation-wise, this could mean that Tracer instances have a reference to their TracerProvider and access configuration only via this reference.

TracerConfigurator
Status: Development

A TracerConfigurator is a function which computes the TracerConfig for a Tracer.

The function MUST accept the following parameter:

tracer_scope: The InstrumentationScope of the Tracer.
The function MUST return the relevant TracerConfig, or some signal indicating that the default TracerConfig should be used. This signal MAY be nil, null, empty, or an instance of the default TracerConfig depending on what is idiomatic in the language.

This function is called when a Tracer is first created, and for each outstanding Tracer when a TracerProvider's TracerConfigurator is updated (if updating is supported). Therefore, it is important that it returns quickly.

TracerConfigurator is modeled as a function to maximize flexibility. However, implementations MAY provide shorthand or helper functions to accommodate common use cases:

Select one or more Tracers by name, with exact match or pattern matching.
Disable one or more specific Tracers.
Disable all Tracers, and selectively enable one or more specific Tracers.
Shutdown
This method provides a way for provider to do any cleanup required.

Shutdown MUST be called only once for each TracerProvider instance. After the call to Shutdown, subsequent attempts to get a Tracer are not allowed. SDKs SHOULD return a valid no-op Tracer for these calls, if possible.

Shutdown SHOULD provide a way to let the caller know whether it succeeded, failed or timed out.

Shutdown SHOULD complete or abort within some timeout. Shutdown can be implemented as a blocking API or an asynchronous API which notifies the caller via a callback or an event. OpenTelemetry client authors can decide if they want to make the shutdown timeout configurable.

Shutdown MUST be implemented at least by invoking Shutdown within all internal processors.

ForceFlush
This method provides a way for provider to immediately export all spans that have not yet been exported for all the internal processors.

ForceFlush SHOULD provide a way to let the caller know whether it succeeded, failed or timed out.

ForceFlush SHOULD complete or abort within some timeout. ForceFlush can be implemented as a blocking API or an asynchronous API which notifies the caller via a callback or an event. OpenTelemetry client authors can decide if they want to make the flush timeout configurable.

ForceFlush MUST invoke ForceFlush on all registered SpanProcessors.

Tracer
Status: Development - Tracer MUST behave according to the TracerConfig computed during Tracer creation. If the TracerProvider supports updating the TracerConfigurator, then upon update the Tracer MUST be updated to behave according to the new TracerConfig.

TracerConfig
Status: Development

A TracerConfig defines various configurable aspects of a Tracer's behavior. It consists of the following parameters:

enabled: A boolean indication of whether the Tracer is enabled.

If not explicitly set, the enabled parameter SHOULD default to true ( i.e. Tracers are enabled by default).

If a Tracer is disabled, it MUST behave equivalently to a No-op Tracer.

The value of enabled MUST be used to resolve whether a Tracer is Enabled. If enabled is false, Enabled returns false. If enabled is true, Enabled returns true.

It is not necessary for implementations to ensure that changes to any of these parameters are immediately visible to callers of Enabled. However, the changes MUST be eventually visible.

Enabled
Status: Development

Enabled MUST return false when either:

there are no registered SpanProcessors,
Tracer is disabled (TracerConfig.enabled is false).
Otherwise, it SHOULD return true. It MAY return false to support additional optimizations and features.

Additional Span Interfaces
The API-level definition for Span's interface only defines write-only access to the span. This is good because instrumentations and applications are not meant to use the data stored in a span for application logic. However, the SDK needs to eventually read back the data in some locations. Thus, the SDK specification defines sets of possible requirements for Span-like parameters:

Readable span: A function receiving this as argument MUST be able to access all information that was added to the span, as listed in the API spec for Span. Note: Below, a few particular properties are called out for clarity, but for the complete list of required properties, the Span API spec is authoritative.

A function receiving this as argument MUST be able to access the InstrumentationScope [since 1.10.0] and Resource information (implicitly) associated with the span. For backwards compatibility it MUST also be able to access the InstrumentationLibrary [deprecated since 1.10.0] having the same name and version values as the InstrumentationScope.

A function receiving this as argument MUST be able to reliably determine whether the Span has ended (some languages might implement this by having an end timestamp of null, others might have an explicit hasEnded boolean).

Counts for attributes, events and links dropped due to collection limits MUST be available for exporters to report as described in the exporters specification.

As an exception to the authoritative set of span properties defined in the API spec, implementations MAY choose not to expose (and store) the full parent Context of the Span but they MUST expose at least the full parent SpanContext.

A function receiving this as argument might not be able to modify the Span.

Note: Typically this will be implemented with a new interface or (immutable) value type. In some languages SpanProcessors may have a different readable span type than exporters (e.g. a SpanData type might contain an immutable snapshot and a ReadableSpan interface might read information directly from the same underlying data structure that the Span interface manipulates).

Read/write span: A function receiving this as argument must have access to both the full span API as defined in the API-level definition for span's interface and additionally must be able to retrieve all information that was added to the span (as with readable span).

It MUST be possible for functions being called with this to somehow obtain the same Span instance and type that the span creation API returned (or will return) to the user (for example, the Span could be one of the parameters passed to such a function, or a getter could be provided).

Sampling
Sampling is a mechanism to control the noise and overhead introduced by OpenTelemetry by reducing the number of samples of traces collected and sent to the backend.

Sampling may be implemented on different stages of a trace collection. The earliest sampling could happen before the trace is actually created, and the latest sampling could happen on the Collector, which is out of process.

The OpenTelemetry API has two properties responsible for the data collection:

IsRecording field of a Span. If false, the current Span discards all tracing data (attributes, events, status, etc.). Users can use this property to determine if collecting expensive trace data can be avoided. Span Processor MUST receive only those spans which have this field set to true. However, Span Exporter SHOULD NOT receive them unless the Sampled flag was also set.
Sampled flag in TraceFlags on SpanContext. This flag is propagated via the SpanContext to child Spans. For more details see the W3C Trace Context specification. This flag indicates that the Span has been sampled and will be exported. Span Exporters MUST receive those spans which have Sampled flag set to true and they SHOULD NOT receive the ones that do not.
The flag combination SampledFlag == false and IsRecording == true means that the current Span does record information, but most likely the child Span will not.

The flag combination SampledFlag == true and IsRecording == false could cause gaps in the distributed trace, and because of this the OpenTelemetry SDK MUST NOT allow this combination.

Recording Sampled reaction table
The following table summarizes the expected behavior for each combination of IsRecording and SampledFlag.

IsRecording	Sampled Flag	Span Processor receives Span?	Span Exporter receives Span?
true	true	true	true
true	false	true	false
false	true	Not allowed	Not allowed
false	false	false	false
The SDK defines the interface Sampler as well as a set of built-in samplers and associates a Sampler with each [TracerProvider].

SDK Span creation
When asked to create a Span, the SDK MUST act as if doing the following in order:

If there is a valid parent trace ID, use it. Otherwise generate a new trace ID (note: this must be done before calling ShouldSample, because it expects a valid trace ID as input).
Query the Sampler's ShouldSample method.
Generate a new span ID for the Span, independently of the sampling decision. This is done so other components (such as logs or exception handling) can rely on a unique span ID, even if the Span is a non-recording instance.
Create a span depending on the decision returned by ShouldSample: see description of ShouldSample's return value below for how to set IsRecording and Sampled on the Span, and the table above on whether to pass the Span to SpanProcessors. A non-recording span MAY be implemented using the same mechanism as when a Span is created without an SDK installed or as described in wrapping a SpanContext in a Span.
Span flags
The OTLP representation for Span and Span Link includes a 32-bit field declared as Span Flags.

Bits 0-7 (8 least significant bits) of the Span Flags field are reserved for the 8 bits of Trace Context flags, specified in the W3C Trace Context Level 2 Candidate Recommendation. See the list of recognized flags.

Sampler
Sampler interface allows users to create custom samplers which will return a sampling SamplingResult based on information that is typically available just before the Span was created.

ShouldSample
Returns the sampling Decision for a Span to be created.

Required arguments:

Context with parent Span. The Span's SpanContext may be invalid to indicate a root span.
TraceId of the Span to be created. If the parent SpanContext contains a valid TraceId, they MUST always match.
Name of the Span to be created.
SpanKind of the Span to be created.
Initial set of Attributes of the Span to be created.
Collection of links that will be associated with the Span to be created. Typically useful for batch operations, see Links Between Spans.
Note: Implementations may "bundle" all or several arguments together in a single object.

Return value:

It produces an output called SamplingResult which contains:

A sampling Decision. One of the following enum values:
DROP - IsRecording will be false, the Span will not be recorded and all events and attributes will be dropped.
RECORD_ONLY - IsRecording will be true, but the Sampled flag MUST NOT be set.
RECORD_AND_SAMPLE - IsRecording will be true and the Sampled flag MUST be set.
A set of span Attributes that will also be added to the Span. The returned object must be immutable (multiple calls may return different immutable objects).
A Tracestate that will be associated with the Span through the new SpanContext. If the sampler returns an empty Tracestate here, the Tracestate will be cleared, so samplers SHOULD normally return the passed-in Tracestate if they do not intend to change it.
GetDescription
Returns the sampler name or short description with the configuration. This may be displayed on debug pages or in the logs. Example: "TraceIdRatioBased{0.000100}".

Description MAY change over time, for example, if the sampler supports dynamic configuration or otherwise adjusts its parameters. Callers SHOULD NOT cache the returned value.

Built-in samplers
OpenTelemetry supports a number of built-in samplers to choose from. The default sampler is ParentBased(root=AlwaysOn).

AlwaysOn
Returns RECORD_AND_SAMPLE always.
Description MUST be AlwaysOnSampler.
AlwaysOff
Returns DROP always.
Description MUST be AlwaysOffSampler.
TraceIdRatioBased
Status: Stable

The TraceIdRatioBased sampler is deprecated in favor of the composable ProbabilitySampler. This component is being phased out to address a "TODO" in the 1.0 trace specification. OpenTelemetry SDK implementors SHALL NOT remove or modify the behavior of the original TraceIdRatioBased sampler until at least January 1, 2027. At that time, SDK implementors are encouraged to silently replace TraceIdRatioBased configuration with an equally-configured ProbabilitySampler.

The TraceIdRatioBased MUST ignore the parent SampledFlag. To respect the parent SampledFlag, the TraceIdRatioBased should be used as a delegate of the ParentBased sampler specified below.
Description MUST return a string of the form "TraceIdRatioBased{RATIO}" with RATIO replaced with the Sampler instance's trace sampling ratio represented as a decimal number. The precision of the number SHOULD follow implementation language standards and SHOULD be high enough to identify when Samplers have different ratios. For example, if a TraceIdRatioBased Sampler had a sampling ratio of 1 to every 10,000 spans it COULD return "TraceIdRatioBased{0.000100}" as its description.
Requirements for TraceIdRatioBased sampler algorithm
Status: Stable

The sampling algorithm MUST be deterministic. A trace identified by a given TraceId is sampled or not independent of language, time, etc. To achieve this, implementations MUST use a deterministic hash of the TraceId when computing the sampling decision. By ensuring this, running the sampler on any child Span will produce the same decision.
A TraceIdRatioBased sampler with a given sampling probability MUST also sample all traces that any TraceIdRatioBased sampler with a lower sampling probability would sample. This is important when a backend system may want to run with a higher sampling probability than the frontend system, this way all frontend traces will still be sampled and extra traces will be sampled on the backend only.
Compatibility warnings for TraceIdRatioBased sampler
Status: Development

WARNING: The exact algorithm was never specified. This sampler is not defined so as to be compatible with any other SDK, therefore is considered unstable. Only the configuration and creation APIs are stable. It is recommended to use this sampler algorithm only for root spans (in combination with ParentBased) because different language SDKs or even different versions of the same language SDKs may produce inconsistent results for the same input.

When this sampler observes a non-empty parent span context, meaning when it is used not as a root sampler, the SDK SHOULD emit a warning such as:

WARNING: The TraceIdRatioBased sampler is operating as a child sampler;
the behavior is subject to change. Please upgrade this SDK configuration
to use ProbabilitySampler.
In such a scenario, this sampler can also detect the use of a ProbabilitySampler by inspecting Tracestate for OpenTelemetry tracestate (ot=...) with th or rv subkeys, in which case the warning MAY be more direct:

WARNING: The TraceIdRatioBased sampler is operating as a child sampler
and a parent is using ProbabilitySampler. Please upgrade this SDK configuration
to use ProbabilitySampler.
ProbabilitySampler
Status: Development

The ProbabilitySampler implements simple, ratio-based probability sampling using randomness features specified in the W3C Trace Context Level 2 Candidate Recommendation. OpenTelemetry follows W3C Trace Context Level 2, which specifies 56 bits of randomness, specifying how to make consistent probability sampling decisions using 56 bits of randomness.

The ProbabilitySampler sampler MUST ignore the parent SampledFlag. For respecting the parent SampledFlag, see the ParentBased sampler specified below.

Note that this is a non-composable form of probability sampler. ProbabilitySampler directly implements the SDKs Sampler API, whereas ComposableProbability is the composable form for use with CompositeSampler.

ProbabilitySampler sampler configuration
The ProbabilitySampler sampler is typically configured using a 32-bit or 64-bit floating point number to express the sampling ratio. The minimum valid sampling ratio is 2^-56, and the maximum valid sampling ratio is 1.0. From an input sampling ratio, a rejection threshold value is calculated; see consistent-probability sampler requirements for details on converting sampling ratios into thresholds with variable precision.

ProbabilitySampler sampler algorithm
Given a Sampler configured with a sampling threshold T and Context with randomness value R (typically, the 7 rightmost bytes of the trace ID), when ShouldSample() is called, it uses the expression R >= T to decide whether to return RECORD_AND_SAMPLE or DROP.

If randomness value (R) is greater or equal to the rejection threshold (T), meaning when (R >= T), return RECORD_AND_SAMPLE, otherwise, return DROP.
When (R >= T), the OpenTelemetry TraceState SHOULD be modified to include the key-value th:T for rejection threshold value (T), as specified for the OpenTelemetry TraceState th sub-key.
Compatibility warnings for ProbabilitySampler
When a ProbabilitySampler makes a decision for a non-root Span based on TraceID randomness, there is a possibility that the TraceID was in fact generated by an older SDK, unaware of this specification. The Trace random flag lets us disambiguate these two cases. This flag propagates information to let ProbabilitySampler Samplers confirm that TraceIDs are random, however this requires W3C Trace Context Level 2 to be supported by every Trace SDK that has handled the context.

When a ProbabilitySampler Sampler makes a decision for a non-root Span using TraceID randomness when the Trace random flag was not set, the SDK SHOULD issue a warning statement in its log with a compatibility warning. As an example of this compatibility warning:

WARNING: The ProbabilitySampler sampler is presuming TraceIDs are random
and expects the Trace random flag to be set in confirmation.  Please
upgrade your caller(s) to use W3C Trace Context Level 2.
ParentBased
This is a sampler decorator. ParentBased helps distinguish between the following cases:
No parent (root span).
Remote parent (SpanContext.IsRemote() == true) with SampledFlag set
Remote parent (SpanContext.IsRemote() == true) with SampledFlag not set
Local parent (SpanContext.IsRemote() == false) with SampledFlag set
Local parent (SpanContext.IsRemote() == false) with SampledFlag not set
Required parameters:

root(Sampler) - Sampler called for spans with no parent (root spans)
Optional parameters:

remoteParentSampled(Sampler) (default: AlwaysOn)
remoteParentNotSampled(Sampler) (default: AlwaysOff)
localParentSampled(Sampler) (default: AlwaysOn)
localParentNotSampled(Sampler) (default: AlwaysOff)
Parent	parent.isRemote()	parent.IsSampled()	Invoke sampler
absent	n/a	n/a	root()
present	true	true	remoteParentSampled()
present	true	false	remoteParentNotSampled()
present	false	true	localParentSampled()
present	false	false	localParentNotSampled()
JaegerRemoteSampler
Jaeger remote sampler allows remotely controlling the sampling configuration for the SDKs. The sampling configuration is periodically loaded from the backend (see Remote Sampling API), where it can be managed by operators via configuration files or even automatically calculated (see Adaptive Sampling). The sampling configuration retrieved by the remote sampler can instruct it to use either a single sampling method for the whole service (e.g., TraceIdRatioBased), or different methods for different endpoints (span names), for example, sample /product endpoint at 10%, /admin endpoint at 100%, and never sample /metrics endpoint.

The full Protobuf definition can be found at jaegertracing/jaeger-idl/api_v2/sampling.proto.

The following configuration properties should be available when creating the sampler:

endpoint - address of a service that implements the Remote Sampling API, such as Jaeger Collector or OpenTelemetry Collector.
polling interval - polling interval for getting configuration from remote
initial sampler - initial sampler that is used before the first configuration is fetched
AlwaysRecord
Status: Development

AlwaysRecord is a sampler decorator that ensures every span is passed to the SpanProcessor, even those that would normally be dropped. It does this by converting DROP decisions from the wrapped sampler into RECORD_ONLY decisions, allowing processors to see all spans without sending them to exporters. This is typically used to enable accurate span-to-metrics processing.

Based on the decision from the wrapped root sampler, AlwaysRecord MUST behave as follows:

Root sampler decision	AlwaysRecord decision
DROP	RECORD_ONLY
RECORD_ONLY	RECORD_ONLY
RECORD_AND_SAMPLE	RECORD_AND_SAMPLE
Required parameters:

root(Sampler) - The sampler being wrapped; it provides the original sample/drop decision that AlwaysRecord modifies.
CompositeSampler
Status: Development

CompositeSampler is a decorator that implements the standard Sampler interface but uses a composition of samplers to make its decisions.

The CompositeSampler takes a ComposableSampler as input and delegates the sampling decision to that interface. See Probability Sampling in TraceState for more details.

ComposableSampler
ComposableSampler is a specialized interface that extends the standard Sampler functionality. It introduces a composable approach to sampling by defining a new method called GetSamplingIntent, which allows multiple samplers to work together in making a sampling decision.

GetSamplingIntent
Returns a SamplingIntent structure that indicates the sampler's preference for sampling a Span, without actually making the final decision.

Required arguments:

All of the original Sampler API parameters are included
Parent context, threshold, incoming trace state, and trace flag information MAY be precomputed so that ComposableSamplers do not repeatedly probe the Context for this information.
Note: ComposableSamplers MUST NOT modify the parameters passed to delegate GetSamplingIntent methods, as they are considered read-only state.

Return value:

The method returns a SamplingIntent structure with the following elements:

threshold - The sampling threshold value. A lower threshold increases the likelihood of sampling.
threshold_reliable - A boolean indicating if the threshold can be reliably used for Span-to-Metrics estimation.
attributes_provider - An optional provider of attributes to be added to the span if it is sampled.
trace_state_provider - An optional provider of a modified TraceState.
Note that trace_state_provider may be a significant source of complexity. ComposableSamplers MUST NOT modify the OpenTelemetry TraceState (i.e., the ot sub-key of TraceState). The calling CompositeSampler SHOULD update the threshold of the outgoing TraceState (unless !threshold_reliable) and that the explicit randomness values MUST not be modified.

Built-in ComposableSamplers
ComposableAlwaysOn
Always returns a SamplingIntent with threshold set to sample all spans (threshold = 0)
Sets threshold_reliable to true
Does not add any attributes